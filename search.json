[{"title":"Promise","path":"/2023/12/15/Promise/","content":"Promise1.什么是Promise12345678910111213141516Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve，race这几个方法，原型上有then、catch等方法。 1. 抽象表达: 1) Promise 是一门新的技术(ES6 规范) 2) Promise 是 JS 中进行异步编程的新解决方案 备注：旧方案是单纯使用回调函数 2. 具体表达: 1) 从语法上来说: Promise 是一个构造函数 2) 从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值 1.1.2. promise 的状态改变 1. pending 变为 resolved 2. pending 变为 rejected 说明: 只有这 2 种, 且一个 promise 对象只能改变一次 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason 2.Promise-API1234567891. Promise 构造函数: Promise (excutor) &#123;&#125;2. Promise.prototype.then 方法: (onResolved, onRejected) =&gt; &#123;&#125; 3. Promise.prototype.catch 方法: (onRejected) =&gt; &#123;&#125; 4. Promise.prototype.finally 方法: () =&gt; &#123;&#125; 5. Promise.resolve 方法: (value) =&gt; &#123;&#125; 6. Promise.reject 方法: (reason) =&gt; &#123;&#125;7. Promise.all 方法: (promises) =&gt; &#123;&#125; 8. Promise.race 方法: (promises) =&gt; &#123;&#125;9. Promise.allSettled 方法: (promises) =&gt; &#123;&#125; 3.关键问题12345671. 如何改变 promise 的状态? 2. 一个 promise 指定多个成功/失败回调函数, 都会调用吗? 3. 改变 promise 状态和指定回调函数谁先谁后? 4. promise.then()返回的新 promise 的结果状态由什么决定? 5. promise 如何串连多个操作任务? 6. promise 异常传透? 7. 中断 promise 链? 4. async 与 await1231. async 函数 2. await 表达式2. 注意点 5. 其他``` bash 1. promise的应用场景 2. promise 、async/await 在事件循环机制中的不同之处","tags":["ceshi"],"categories":["前端"]},{"title":"Hello World","path":"/2023/12/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"about","path":"/about/index.html","content":"开发中…"},{"title":"这是分页标题","path":"/wiki/cat/index.html","content":"Quick Startfirst12345我的第一只猫不属于我，她叫皮蛋。2021年在朴园酒店打工时遇到她，是老板家的猫。嗯...品种是蓝猫。在那里上夜班总有她陪着我，我也想陪着她，也是她让我有了以后一定养一只猫的想法。大概10月左右，皮蛋因为躺在一辆车底下睡觉，发生了意外，她的一生还有一些其他的不幸。永远感谢她的短暂陪伴 123422年有了程序员的工作，也有了干不完的活，在7月份我买了我的第一只小布偶，此刻在我旁边已经是只大布偶了，他的名字叫鱼宝（公），就和这个博客站点的名字一样，是我用了多年的网名在那大概一周后，我买了第二只小猫（母），是一只长毛银点，她的名字叫一心。不得不说我去浦东机场接她的那天，是在周天，既已如此深刻，是因为前一天的周六加班了，通！宵！加！班！至此我拥有了两只小猫，让独居生活有了很多乐趣，之后也买了自行车，爱上了骑行，那时感觉生活越来越有希望了，和此刻的心境截然相反。 123423年5.12，鱼宝和一心当了爸爸妈妈，生了四只小猫23年9.19，鱼宝和一心再次当了爸爸妈妈，生了五只小猫 1234此刻是2023.12.15，23：45家里已经有了十一只猫，燃眉之急是找到工作，活下去，其次已经给两只小猫找到领养，其他的还要接着找，让小猫们也能好好活下去。"},{"title":"ceshiceshi","path":"/wiki/cola/index.html","content":"我爱喝可口可乐"},{"title":"Promise","path":"/notes/front/Promise.html","content":"Promise1.什么是Promise12345678910111213141516Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve，race这几个方法，原型上有then、catch等方法。 1. 抽象表达: 1) Promise 是一门新的技术(ES6 规范) 2) Promise 是 JS 中进行异步编程的新解决方案 备注：旧方案是单纯使用回调函数 2. 具体表达: 1) 从语法上来说: Promise 是一个构造函数 2) 从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值 1.1.2. promise 的状态改变 1. pending 变为 resolved 2. pending 变为 rejected 说明: 只有这 2 种, 且一个 promise 对象只能改变一次 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason 2.Promise-API1234567891. Promise 构造函数: Promise (excutor) &#123;&#125;2. Promise.prototype.then 方法: (onResolved, onRejected) =&gt; &#123;&#125; 3. Promise.prototype.catch 方法: (onRejected) =&gt; &#123;&#125; 4. Promise.prototype.finally 方法: () =&gt; &#123;&#125; 5. Promise.resolve 方法: (value) =&gt; &#123;&#125; 6. Promise.reject 方法: (reason) =&gt; &#123;&#125;7. Promise.all 方法: (promises) =&gt; &#123;&#125; 8. Promise.race 方法: (promises) =&gt; &#123;&#125;9. Promise.allSettled 方法: (promises) =&gt; &#123;&#125; 3.关键问题12345671. 如何改变 promise 的状态? 2. 一个 promise 指定多个成功/失败回调函数, 都会调用吗? 3. 改变 promise 状态和指定回调函数谁先谁后? 4. promise.then()返回的新 promise 的结果状态由什么决定? 5. promise 如何串连多个操作任务? 6. promise 异常传透? 7. 中断 promise 链? 4. async 与 await1231. async 函数 2. await 表达式2. 注意点 5. 其他``` bash 1. promise的应用场景 2. promise 、async/await 在事件循环机制中的不同之处"},{"title":"notes","path":"/notes/index.html","content":"fghfhgfgh"},{"title":"Promise","path":"/notes/front/js.html","content":"JS 中常用的数据类型 基本数据类型 数字number 常规数字和NaN 字符串string 所有用单引号、双引号、反引号（撇）包起来的都是字符串 布尔boolean true&#x2F;false 空对象指针null 未定义undefined 引用数据类型 对象数据类型object {} 普通对象 [] 数组对象 正则对象 Math数学函数对象 日期对象 … 函数数据类型function number数字类型 包含：常规数字、NaN NaN not a number: 不是一个数，但它属于数字类型 NaN和任何值（包括自己）都不相等：NaN !&#x3D; NaN，所以我们不能用相等的方式判断是否为有效数字 isNaN 检测一个值是否为有效数字，如果不是有效数字返回TRUE,反之是有效数字返回FALSEconsole.log(isNaN(10)) &#x2F;&#x2F;false console.log(isNaN(‘AA’)) &#x2F;&#x2F;trueNumber(‘AA’) &#x3D;&gt; NaNisNaN(NaN) &#x3D;&gt; true console.log(isNaN(‘10’)) &#x2F;&#x2F;falseNumber(‘10’) &#x3D;&gt; 10isNaN(10) &#x3D;&gt; true 在使用isNaN进行检测的时候，首先会验证检测的值是否为数字类型，，如果不是，先基于Number()这个方法，把值转换为数字类型，然后再检测 把其他类型值转换为数字类型 Number([val]) 把字符串转换为数字，只要字符串中包含任意一个非有效数字字符（第一个点除外）结果都是NaN，空字符串会变为数字零 console.log(Number(‘12.5’)) &#x2F;&#x2F;12.5 console.log(Number(‘12.5px’)) &#x2F;&#x2F;NaN console.log(Number(‘12.5.5’)) &#x2F;&#x2F;NaN console.log(Number(‘’)) &#x2F;&#x2F;0 布尔转换为数字 console.log(Number(true)) &#x2F;&#x2F;1 console.log(Number(false)) &#x2F;&#x2F;0 console.log(isNaN(false)) &#x2F;&#x2F;false null,undefined转换为数字 console.log(Number(null)) &#x2F;&#x2F;0 console.log(Number(undefined)) &#x2F;&#x2F;NaN 把引用数据类型转换为数字，是先把他基于toString方法转换为字符串，然后再转换为数字 console.log(Number({name:’10’})) &#x2F;&#x2F;NaN console.log(Number({})) &#x2F;&#x2F;NaN &#x2F;&#x2F; {}&#x2F;{xxx:’xxx’}.toString() &#x3D;&gt; “[object Object]” &#x3D;&gt; NaN console.log(Number([])) &#x2F;&#x2F;0 &#x2F;&#x2F; [].toString() &#x3D;&gt; ‘’ console.log(Number([12])) &#x2F;&#x2F;12 &#x2F;&#x2F; [12].toString() &#x3D;&gt; ‘12’ console.log(Number([12,23])) &#x2F;&#x2F;NaN &#x2F;&#x2F; [12,23].toString() &#x3D;&gt; ‘12,23’ parseInt&#x2F;parseFloat([val],[进制]): 也是转换为数字的方法，遂于字符串来说，它是从左到右依次查找有效数字字符，直到遇到非有效数字字符，停止查找（不管后面是否还有数字，都不在找了），把找到的当作数字返回 let str &#x3D; ‘12.5px’; console.log(Number(str)) &#x2F;&#x2F;NaN console.log(parseInt(str)) &#x2F;&#x2F;12 console.log(parseFloat(str)) &#x2F;&#x2F;12.5 console.log(parseFloat(‘width:12.5px’)) &#x2F;&#x2F;NaN &#x3D;&#x3D; 进行比较的时候，可能要出现把其他类型值转换为数字 string字符串数据类型 所有用单引号、双引号、反引号（撇 ES6模板字符串）包起来的都是字符串 把其他类型值转换为字符串 [val].toString() &#x2F;&#x2F;null和undefined是禁止直接toString的 &#x2F;&#x2F;(null).toString() &#x2F;&#x2F; &#x3D;&gt;报错 &#x2F;&#x2F;但是和undefined一样转换为字符串的结果就是’null’&#x2F;‘undefined’ &#x2F;&#x2F;普通对象.toString()的结果是”[object Object]” &#x3D;&gt; Object.prototype.toString方法不是转换为字符串的，而是用来监测数据类型的 字符串拼接 &#x2F;&#x2F;四则运算法则中，除加法之外，其余都是数学计算，只有加法可能存在字符串拼接（一旦遇到字符串，则不是数学运算，而是字符串拼接） console.log(‘10’+10) &#x2F;&#x2F; &#x3D;&gt; ‘1010’ console.log(‘10’-10) &#x2F;&#x2F; &#x3D;&gt; 0 console.log(‘10px’-10) &#x2F;&#x2F; &#x3D;&gt; NaN boolean布尔数据类型 只有两个值 true&#x2F;false 把其他类型值转换为布尔类型 只有 0、NaN、’’、null、undefined 五个值转换为false，其余转换结果都是true(而且没有任何特殊情况) Boolean([val]) !&#x2F;!! &#x2F;&#x2F;!:取反(先转为布尔，然后取反) !!:取反再取反，只相当于转换为布尔&lt;&#x3D;&gt; Boolean console.log(!1) &#x2F;&#x2F; &#x3D;&gt; false console.log(!!,) &#x2F;&#x2F; &#x3D;&gt; true 条件判断 null &#x2F; undefined null和undefined都代表的是没有 null: 意料之中(一般都是开始不知道值，我们手动设置为null，后期再给予赋值操作) let num &#x3D; null; &#x2F;&#x2F; &#x3D;&gt; let num &#x3D; 0; 一般最好用null作为初始的空值，因为零不是空值，他在栈内存中有自己的存储空间（占了位置），因此null会更节约性能 undefined： 意料之外(不是我能决定的) let num; &#x2F;&#x2F;&#x3D;&gt; 创建一个变量没有赋值，默认值是undefined object对象数据类型-普通对象 {[key]:[value],…} 任何一个对象都是由零到多组键值对(属性名：属性值)组成的(并且属性名不能重复) &#x2F;&#x2F;获取属性名对应的属性值 &#x2F;&#x2F; &#x3D;&gt; 对象.属性名 &#x2F;&#x2F; &#x3D;&gt; 对象[属性名] 属性名是数字或者字符串格式的 &#x2F;&#x2F; &#x3D;&gt; 如果当前属性名不存在，默认的属性值是undefined &#x2F;&#x2F; &#x3D;&gt; 如果属性名是数字，则不能使用点的方式获取属性值 // 删除属性 =&gt;真删除：把属性彻底干掉 delete 对象[&#39;属性名&#39;] =&gt;假删除：属性还在，值为空 属性名.属性值 = null/undefined 数组是特殊的对象数据类型 1.我们中括号中设置的是属性值，它的属性名是默认生成的数字，从零开始递增，而且这个数字代表每一项的位置，我们把其称为’索引’ &#x3D;&gt; 从零开始，连续递增，代表每一项位置的数字属性名 2.天生一个属性名length，存储数组的长度 JS中的数据类型检测 typeof[val]: 用来检测数据类型的运算符 instanceof： 用来检测当前实例是否属于某个类 constructor： 基于构造函数检测数据类型(也是基于类的方式) Object.prototype.toString.call(): 检测数据类型最好的办法 基于typeof检测出来的结果 1.首先是一个字符串 2.字符串中包含对应的类型 局限性 1.typeof null &#x3D;&gt; ‘object’ 但是null不是对象 2.基于typeof无法细分出当前值是普通对象还是数组对象等，因为只要是对象数据类型，返回的结果都是’object’ JS中的操作语句: 判断、循环判断 条件成立做什么？不成立做什么？ if&#x2F;else if&#x2F;else 三元运算符 switch case 1.if&#x2F;else 1234567if(条件)&#123; 条件成立执行&#125;else if(条件2)&#123; 条件2成立执行&#125;else&#123; 以上条件都不成立执行&#125; 2.三元运算符：简单if&#x2F;else的特殊处理方式 条件?条件成立处理的事情：不成立处理的事情； 1.如果处理的事情比较多，我们用括号抱起来，没一件事情用都好分隔 2.如果不需要处理事情，可以使用null&#x2F;undefined占位 3.switch case 一个变量在不同值情况下的不同操作 1.每一种case情况结束后最好都加上break，不加break，当前条件执行完成后，后面条件不论是都成立都要执行，直到遇到break为止 2.default等价于else，以上都不成立干的事情 3.每一种case情况的比较用的都是&#x3D;&#x3D;&#x3D;“绝对相等” &#x3D;&#x3D; vs &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;：相等(如果左右两边数据值类型不同，是默认先转换为相同的类型，然后比较)&#x3D;&#x3D;&#x3D;：绝对相等(如果类型不一样，肯定不相等，不会默认转换数据类型) 循环 重复做某些事情就是循环 for循环 for in循环 for of循环(ES6新增) while循环 do while循环 函数 function 函数就是一个方法或者一个功能体，函数就是把实现某个功能的代码放到一起进行封装，以后想要操作实现这个功能，只需要把函数执行即可 &#x3D;&gt; ‘封装’：减少页面中的冗余代码，提高代码重复使用率(低耦合高内聚) 创建函数 形参 返回值 执行函数 实参 arguments 函数的底层运行机制 创建函数12345function [函数名]([形参变量1]，...)&#123; 函数体：基于JS完成需要实现的功能 return[处理后的结果];&#125;[函数名]([实参1]，...) &#x2F;&#x2F;形参：&#x2F;&#x2F;创建函数的时候我们设置了形参变量，但如果执行的时候并没有给传递对应的实参值，那么形参变量默认的值是：undefined，此时若遇到计算，则会出现转换为NaN，因此一般形参会提供默认值 &#x2F;&#x2F;函数中的返回值：&#x2F;&#x2F;函数执行的时候，函数体内部创建的变量我们是无法获取和操作的，如果要想获取内部的信息，我们需要基于return返回值机制，把信息返回才可以，没有写return，函数默认返回值是undefined &#x2F;&#x2F;匿名函数：&#x2F;&#x2F;匿名函数之函数表达式:把一个匿名函数本身作为值赋值给其它东西，这种函数一般不是手动触发执行，而且靠其它程序驱动触发执行(例如:触发某个事件的时候把它执行等)document.body.onclick &#x3D; function () {}|setTimeout(ffunction(){},1000)(function(n){})(100); &#x2F;&#x2F;匿名函数之自执行函数：创建完一个匿名函数，紧接着就把当前函数加小括号执行 浏览器常用的输出方式1.console.log&#x2F;dir&#x2F;table…在控制台输出 .dir : 输出一个对象的详细的键值对信息 .table : 把一个多维json数组在控制台按照表格的方式呈现出来 2.浏览器窗口弹窗 alert&#x2F;confirm&#x2F;prompt &#x3D;&gt; 三种方式输出的结果就都必先经过toString转换为字符串 &#x3D;&gt; 三种方式会阻断JS代码执行，只有当窗口关掉，JS才会继续执行 3.document.write在页面中写入信息 &#x3D;&gt; 先经过toString转换为字符串"}]